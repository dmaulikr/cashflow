// Generated by O/R mapper generator ver 0.1(cashflow)

package org.tmurakam.cashflow.ormapper;

import java.util.*;
import android.content.ContentValues;
import android.database.*;
import android.database.sqlite.*;

import org.tmurakam.cashflow.ormapper.ORRecord;

public class CategoryBase extends ORRecord {
    public int pid;
    protected boolean isInserted = false;

    public String name;
    public int sorder;


    /**
      @brief Migrate database table
      @return YES - table was newly created, NO - table already exists
    */
    public static boolean migrate() {
        String[] columnTypes = {
        "name", "TEXT",
        "sorder", "INTEGER",
        };

        return migrate(columnTypes);
    }

    /**
      @brief allocate entry
    */
    public static CategoryBase allocator() {
        return new CategoryBase();
    }

    // Read operations

    /**
      @brief get the record matchs the id

      @param pid Primary key of the record
      @return record
    */
    public static CategoryBase find(int pid) {
        SQLiteDatabase db = Database.instance();

        String[] param = { Integer.toString(pid) };
        Cursor cursor = db.rawQuery("SELECT * FROM Categories WHERE key = ?;", param);

        CategoryBase e = null;
        cursor.moveToFirst();
        if (!cursor.isAfterLast()) {
            e = allocator();
            e._loadRow(cursor);
        }
        cursor.close();
 
        return e;
    }
    /**
       @brief get all records matche the conditions

       @param cond Conditions (WHERE phrase and so on)
       @return array of records
    */
    public static ArrayList<CategoryBase> find_cond(String cond) {
        return find_cond(cond, null);
    }

    public static ArrayList<CategoryBase> find_cond(String cond, String[] param) {
        String sql;
        sql = "SELECT * FROM Categories";
        if (cond != null) {
            sql += " ";
            sql += cond;
        }
        SQLiteDatabase db = Database.instance();
        Cursor cursor = db.rawQuery(sql, param);
        cursor.moveToFirst();

        ArrayList<CategoryBase> array = new ArrayList<CategoryBase>();

        while (!cursor.isAfterLast()) {
            CategoryBase e = allocator();
            e._loadRow(cursor);
            array.add(e);
        }
        return array;
    }

    private void _loadRow(Cursor cursor) {
        this.pid = cursor.getInt(0);
        this.name = cursor.getString(1);
        this.sorder = cursor.getInt(2);

        isInserted = true;
    }

    // Create operations

    public void insert() {
        super.insert();

        SQLiteDatabase db = Database.instance();

	// TBD: pid should be long?
        this.pid = (int)db.insert("Categories", "key"/*TBD*/, getContentValues());

        //[db commitTransaction];
        isInserted = true;
    }

    // Update operations

    public void update() {
        super.update();

        SQLiteDatabase db = Database.instance();
        //[db beginTransaction];

        ContentValues cv = getContentValues();

        String[] whereArgs = { Long.toString(pid) };
        db.update("Categories", cv, "WHERE key = ?", whereArgs);

        //[db commitTransaction];
    }

    private ContentValues getContentValues()
    {
        ContentValues cv = new ContentValues(2);
        cv.put("name", this.name);
        cv.put("sorder", this.sorder);

        return cv;
    }

    // Delete operations

    /**
       @brief Delete record
    */
    public void delete() {
        SQLiteDatabase db = Database.instance();

        String[] whereArgs = { Long.toString(pid) };
        db.delete("Categories", "WHERE key = ?", whereArgs);
    }

    /**
       @brief Delete all records
    */
    public static void delete_cond(String cond) {
        SQLiteDatabase db = Database.instance();

        if (cond == null) {
            cond = "";
        }
        String sql = "DELETE FROM Categories " + cond;
        db.execSQL(sql);
    }

    // Internal functions

    public static String tableName() {
        return "Categories";
    }
}
